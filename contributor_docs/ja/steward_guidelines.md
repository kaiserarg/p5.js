# 管理者ガイド
管理者として新しく参加した方、p5.jsの経験豊富なメンテナー、またはその中間の方であるかに関わらず、このガイドには、p5.jsへの貢献を効果的に行うための多くの情報、ヒント、トリックが含まれています。ここに書かれているほとんどの内容はガイドラインであり、特に指示がない限り、あなたのワークフローに合わせてここに示されている方法を適応させることができます。

# 目次
-  [問題](#問題)
 - [バグ報告](#バグ報告)
 - [機能リクエスト](#機能リクエスト)
 - [機能強化](#機能強化)
 - [議論](#議論)
- [プルリクエスト]#(プルリクエス)
 - [簡単な修正](#簡単な修正)
 - [バグ修正](#バグ修正)
 - [新機能/機能強化](#新機能/機能強化)
 - [Dependabot](#Dependabot)
- [ビルドプロセス](#ビルドプロセス)
 - [主要なビルドタスク](#主要なビルドタスク)
 - [その他のタスク](#その他のタスク)
- [リリースプロセス](#リリースプロセス)
- [ヒントとコツ](#ヒントとコツ)
 - [返信テンプレート](#返信テンプレート)
 - [GitHub CLI](#github-cli)
 - [通知管理](#通知管理)

---

# 問題
我々は、ほとんどのソースコードの貢献が問題から始まることを奨励しており、そのため、問題はほとんどの議論が行われる場所です。問題をレビューする際に取ることができるステップは、問題のタイプによって異なります。このリポジトリでは、[GitHub問題テンプレート](../.github/ISSUE_TEMPLATE)を使用して、異なるタイプの問題をよりよく整理し、問題提起者に関連情報の提供を奨励しています。問題をレビューする最初のステップは通常、提供されたテンプレートを確認し、追加情報が必要かどうか（フィールドが未記入であるか、間違ったテンプレートが使用されているかなど）を判断することです。

## バグ報告
バグ報告の問題には、「バグを見つけました」の問題テンプレートが使用されるべきです。

1. バグの再現
   - テンプレートの目的は、レビュアーが報告されたバグを再現できるようにすることです。
   - 報告されたバグが該当リポジトリ（p5.jsまたはp5.js-website）と関係ない場合。
     - 関連リポジトリへのアクセス権がある場合は、問題を関連リポジトリに転送してください。
     - そうでない場合は、問題にコメントを残し、バグ報告をどこに提出すべきか（直接リンクを提供する）を説明し、その後問題を閉じてください。
   - バグ報告の最初のステップは、バグを再現するために十分な情報が提供されているかを確認し、必要に応じて説明に従ってバグを再現しようとすることです。
2. バグが再現できる場合
   - 特定のバグを修正する最善の方法を決定するための議論が時には必要です。これは簡単な場合もあれば、複雑な場合もあります。決定を下す際には、[p5.jsの設計原則](./design_principles.md)を参照してください。
   - 如果问题作者在问题中表示愿意提供修复方法。
     - コメントを残して問題を問題提起者に割り当てる（「Assignee」の隣の右側のギアボタンを使用）ことで、問題提起者による問題の修正を承認します。
   - 問題提起者が修正方法を提供することを希望していない場合。
     - コメントを残してバグが再現可能であることを確認します。
     - 自分で修正を試みるか、問題に「助けが必要」のラベルを追加して、修正が必要な問題を示します。
3. バグが再現できない場合
   - テンプレートで追加情報（p5.jsのバージョン、ブラウザのバージョン、オペレーティングシステムのバージョンなど）がまだ提供されていない場合は、追加情報の提供を求めてください。
   - テスト環境が問題で報告されたものと異なる場合（異なるブラウザやオペレーティングシステムなど）。
     - 自分の特定の環境で再現できなかったことをコメントで説明します。
     - 問題に「助けが必要」のラベルを追加し、問題で指定された設定を持つ他の人にそのバグを再現してみてもらうよう求めます。
   - 時には、Webエディターを使用しているときにのみバグが発生し、ローカルでテストしているときには発生しない場合があります。このような場合、問題は[Webエディター  リ ポジトリ](https://github.com/processing/p5.js-web-editor)に転送されるべきです。
   - 後にバグを再現できるようになった場合は、ステップ2に戻ります。
4. バグが提供されたサンプルコードに由来し、p5.jsの挙動ではない場合
   - p5.jsのドキュメント、コードの実装、または親切なエラーシステムを改善することで、同様の誤りを防ぐことができるかどうかを判断します。
   - 任意のさらなる問題を[フォーラム](https://discourse.processing.org/)に優しくリダイレクトし、p5.jsにさらなる変更がない場合は問題を閉じます。

## 機能リクエスト
機能リクエストの問題には、「新機能リクエスト」の問題テンプレートを使用してください。

1. p5.jsのアクセシビリティを向上させる一環として、すべての機能リクエストは、それがどのようにp5.jsのアクセシビリティをその分野で歴史的にマイノリティであるコミュニティに向けて向上させるかを説明する必要があります。詳細は[こちら](./access.md)を参照してください。
   - 機能リクエストが「アクセシビリティの向上」のフィールドを十分に記入していない場合、問題提起者にその機能がどのようにアクセシビリティを向上させるか説明を求めることができます。
   - アクセシビリティの説明は、コミュニティの他のメンバー（問題レビュアー自身を含む）から提供されることがあります。
2. 提案された新機能リクエストが含まれるべきかどうかを以下の基準に基づいて評価します。
   - それはp5.jsのプロジェクトの範囲と[設計原則](./design_principles.md)に合致していますか？
     - 新しい描画プリミティブの追加リクエストは考慮されるかもしれませんが、ブラウザベースのIoTプロトコルのリクエストは範囲外かもしれません。
     - 全体として、p5.jsの範囲は比較的狭く保たれるべきであり、稀な機能による過度の膨張を避けるべきです。
     - 機能がp5.jsの範囲に合致しない場合、問題の提起者またはコミュニティの他のメンバーによって、その機能を追加ライブラリとして実装することができます。
   - それは破壊的変更と見なされる可能性がありますか？
     - それは既存のp5.jsの関数や変数と衝突しますか？
     - それはp5.jsで既に書かれている典型的な例と衝突しますか？
     - 上記の衝突を引き起こす可能性のある機能は破壊的変更と見なされ、メジャーバージョンリリースがない限り、p5.jsに破壊的変更を加えるべきではありません。
   - 提案された新機能は、既存のp5.jsの機能、比較的簡単なネイティブJavaScriptコード、または既存の使いやすいライブラリを使用して実装することができますか？
     - たとえば、`join(["Hello", "world!"])`のような文字列配列を連結するためのp5.js関数を提供する必要はありません。代わりに、ネイティブJavaScriptの`["Hello", "world!"].join()`を使用することを優先すべきです。
3. アクセシビリティの要件と他の考慮事項を満たす場合、PRを開始する前に少なくとも2人の管理者またはメンテナーの承認が必要です。新機能のPRレビュープロセスは以下で詳しく説明されています。

## 機能強化
機能強化の問題には、「既存機能の強化」の問題テンプレートを使用してください。ここでのプロセスは新機能リクエストと非常に似ています。新機能リクエストと機能強化の違いは少し曖昧かもしれませんが、機能強化は主にp5.jsの既存の機能に関連し、新機能リクエストは全く新しい機能の追加をリクエストする場合があります。

1. 新機能リクエストと同様に、機能強化はp5.jsへのアクセスを増加させる場合にのみ受け入れられるべきです。上記の[機能リクエストのセクション1](#機能リクエスト)を参照してください。
2. 機能強化の包含基準は上記の機能リクエストと似ていますが、潜在的な破壊的変更に特に注意してください。
   - 既存の機能を変更する場合、以前に有効でドキュメント化されたすべての関数シグネチャは、同じ方法で動作する必要があります。
3. PRを開始する前に、少なくとも1人の管理者またはメンテナーによる機能強化の承認が必要です。機能強化のPRレビュープロセスは以下で詳しく説明されています。

## 議論
このタイプの問題にはシンプルなテンプレート（「議論」）があり、他の3つの既存のテンプレートに適合しない特定の議論や、フォーラムやDiscordでの議論に適している場合にのみ使用されます。

- 議論として問題が開かれたが、バグ報告であるべき場合は、適切なタグを適用し、「議論」タグを削除してください。追加情報が含まれていない場合（上述の[バグ報告](#バグ報告)に従って）、さらに情報の提供を求めてください。
- 議論として問題が開かれたが、ソースコードの貢献やその他のGitHubリポジトリ/貢献プロセス/貢献コミュニティに関連する問題に関連しない場合（例えば、p5.jsのスケッチに最適なプロジェクターのタイプについての議論）、フォーラムやDiscordにリダイレクトして問題を閉じてください。
- 適用される場合、さらに議論のタイプを特定するために他のラベルを議論の問題に追加してください。


---

# プルリクエスト
ほぼ全てのp5.jsリポジトリへのコード貢献はプルリクエストを通じて行われます。管理者やメンテナーはリポジトリへのプッシュアクセス権を持っているかもしれませんが、コードを貢献する際には、同じ問題 > プルリクエスト > レビュープロセスに従うことを奨励します。以下は、プルリクエストをレビューする際に取ることができるいくつかのステップです。

- プルリクエストのテンプレートは[こちら](../.github/PULL_REQUEST_TEMPLATE.md)で見つけることができます。
- ほとんどのプルリクエストは、関連する問題が先に開かれて議論される必要があります。これは、管理者やメンテナーがPRをレビューする前に、関連する[問題のワークフロー](#issues)に従って行動される必要があることを意味します。
	- このルールの唯一の例外は、非常に小さなスペルの間違いの修正であり、問題を開く必要はありません。これらの修正は、マージアクセス権を持つ誰でもマージできますが、特定の領域の管理者ではなくても構いません。
	- この例外が存在するにもかかわらず、実際には、新しい問題の開始を奨励する状況でのみこれを適用します。つまり、この例外が適用されるかどうかに疑問がある場合は、単に問題を開いてください。
- プルリクエストが参照している問題を完全に解決できない場合は、オリジナルの投稿を編集して「解決 #OOOO」を「処理 #OOOO」に変更し、このPRがマージされたときに元の問題が自動的に閉じられないようにできます。

## 簡単な修正
小さなスペルミスの修正など、簡単な修正は、マージアクセス権を持つ任意の人が直接マージできます。PRの「変更されたファイル」タブで素早くチェックし、自動CIテストが通過していることを確認するだけで十分です。

## バグ修正
1. バグ修正は、関連分野の管理者によってレビューされるべきであり、できれば同じ問題を修正することに同意した同じ人が最適です。
2. PRの「変更されたファイル」タブを使用して、修正が問題の議論で説明されたものと一致しているかどうかを初期レビューできます。
3. 必要であれば、ローカルで必要なテストを行ってください。GitHub CLIは、このプロセスの一部を簡素化するのに役立ちます。（下記の[Tips＆Tricks](#tips-tricks)で詳細をご覧ください）。
	- 修正は元の問題を十分に解決する必要があります。
	- 修正は既存の挙動を変更すべきではありません。元の問題で合意が得られていない限り。
	- 修正はp5.jsのパフォーマンスに重大な影響を与えるべきではありません。
	- 修正はp5.jsのアクセシビリティに影響を与えるべきではありません。
	- 修正は現代のJavaScriptコーディング標準を使用するべきです。
	- 修正は全ての自動テストを通過する必要があり、関連する場合は新しいテストを含むべきです。
4. 他の変更が必要な場合は、[ここ](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)に記載されているように、関連する行に行レベルのコメントを追加してください。
   - 具体的な変更を提案するために提案ブロックを使用することもできます。
   - 複数の変更が必要な場合は、一度に複数の行にコメントを追加するのではなく、[ここ](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/reviewing-proposed-changes-in-a-pull-request)に記載されているように、複数行にわたってコメントを追加し、変更をリクエストしてください。
   - 行レベルのコメントが単に明確化や議論のためであり、変更をリクエストしていない場合は、「Request changes」ではなく「Comment」を選択してください。
5. PRがレビューされ、他の変更が必要ない場合は、責任者は「Approve」オプションを選択して（「Comment」や「Request changes」ではなく）PRを「Approved」としてマークできます。その後、必要に応じて他の責任者やメンテナーにさらにレビューを求めるか、マージアクセス権を持っている場合はPRをマージするか、メンテナーが承認されたPRをマージします。
6. @all-contributorsボットを呼び出して、README.mdファイルの貢献者リストに新しい貢献者を追加してください。

```
@all-contributors please add @[github handle] for [contribution type]
```


## 新機能/機能強化
新機能または機能強化のPRのプロセスはバグ修正と似ていますが、一つの顕著な違いがあります。

- 新機能/機能強化のPRは、合併される前に少なくとも2名の管理者またはメンテナーによってレビューおよび承認される必要があります。
  - これは、元の問題を承認した同じ2名の管理者またはメンテナーである場合もあれば、他の人物である場合もあります。

## Dependabot
DependabotのPRは通常、リポジトリの管理者にのみ表示されます。これが関係ない場合は、このセクションをスキップしてください。

- バージョンアップデートがセマンティックなパッチバージョンであり、自動CIテストが通過している場合は、Dependabot PRを直接マージすることができます。
- Dependabot PRがセマンティックなマイナーバージョン変更を伴う場合、自動CIテストが通過していれば通常直接マージすることができますが、更新された依存関係の変更ログを素早く確認することをお勧めします。
- Dependabot PRがセマンティックなメジャーバージョン変更を伴う場合、ビルドプロセスやp5.jsの機能に影響を与える可能性があります。この場合、レビュアーは可能な限り現在のバージョンから目標バージョンまでの変更ログをチェックし、ローカルでPRをテストして、すべてのプロセスが正常に動作し、依存関係の潜在的なメジャー変更に基づいて必要な変更を行うことを奨励されます。
  - 多くの依存関係がメジャーバージョンを上げる理由は、非常に古いnode.jsバージョンの公式サポートをやめたためであり、これは多くの場合、依存関係のAPI変更による破壊的変更を意味するわけではないことを意味します。

---

# ビルドプロセス
このセクションでは、一般的なビルドの設定やコマンドについては扱わず、背後で起こっている詳細に焦点を当てます。上記の内容については、[貢献者ガイド](./contributor_guidelines.md#working-on-p5js-codebase)を参照してください。

Gruntfile.jsファイルには、p5.jsおよびその他のコンテンツの主要なビルド定義が含まれています。ビルドライブラリやドキュメントで使用されるさまざまなツールには、Grunt、Browserify、YUIDoc、ESLint、Babel、Uglify、Mochaなどがあります。`default`タスクから始めて、逆方向で分析すると役立つかもしれません。

## 主要なビルドタスク


```js
grunt.registerTask('default', ['lint', 'test']);
```
`grunt`やnpmスクリプトの`npm test`を実行すると、`lint`と`test`を含むデフォルトタスクが実行されます。

```js
grunt.registerTask('lint', ['lint:source', 'lint:samples']);
```
`lint`タスクには、`lint:source`と`lint:samples`の2つのサブタスクが含まれます。`lint:source`はさらに、`eslint:build`、`eslint:source`、そして`eslint:test`の3つのサブタスクに分かれており、これらはESLintを使用してビルドスクリプト、ソースコード、テストスクリプトを検査します。

`lint:samples`タスクはまず`yui`タスクを実行し、このタスク自体が`yuidoc:prod`、`clean:reference`、そして`minjson`を含んでいます。これらはソースコードからドキュメントをJSONファイルに抽出し、前のステップで使用されなかったファイルを削除し、生成されたJSONファイルを`data.min.json`に圧縮します。次に、`lint:samples`内では、[./tasks/build/eslint-samples.js](./tasks/build/eslint-samples.js)に定義されている`eslint-samples:source`というカスタムタスクがあり、これはESLintを使用してドキュメントのサンプルコードを検査し、p5.jsの残りの部分と同じコーディング標準に従っていることを確認します（ここで`yui`が最初に実行されるのは、サンプルを検査する前にJSONファイルを構築する必要があるためです）。


```js
grunt.registerTask('test', [
  'build',
  'connect:server',
  'mochaChrome',
  'mochaTest',
  'nyc:report'
]);
```
まず、`test`内の`build`タスクを見てみましょう。
```js
grunt.registerTask('build', [
  'browserify',
  'browserify:min',
  'uglify',
  'browserify:test'
]);
```
browserifyステップでは、様々なファイルを一つに結合するだけでなく、いくつかの追加ステップも実行されます。まず、`brfs-babel`を使用して`fs.readFileSync()`ノード.js特有のコードの使用を実際のファイルの内容で置き換えます。これは主にWebGLコードで使用され、シェーダーコードをインラインで保持しつつ、それらを別々のファイルとしても保持します。

次に、Babelを使用してnode_modulesからのすべての依存関係のソースコードをトランスパイルし、package.jsonで定義されたBrowserslistの要件に合わせ、ES6のimport文をbrowserifyが理解するCommonJSの`require()`に変換します。これにより、ES6やそれ以上の新しい構文を、ブラウザの互換性を過度に心配することなく使用できるようになります。

バンドル後にコードをファイルに書き出す前に、コードを縮小する予定がない場合は、`pretty-fast`を通じてクリーンアップを行い、最終的なフォーマットをより一貫性のあるものにします（必要に応じてp5.jsのソースコードを読んで確認できることを期待しています）。

ここでは細かい詳細は省略しましたが、上記のリンクからbrowserifyのビルド定義ファイルを見て、全体の詳細をより深く理解することができます。


```
connect:server
```
このステップは、テストファイルとビルドされたソースコードファイルをホストするローカルサーバーを起動し、Chromeで自動テストを実行できるようにします。

```
mochaChrome
```
このステップは[./tasks/test/mocha-chrome.js](./tasks/test/mocha-chrome.js)で定義されています。Puppeteerを使用してヘッドレス版のChromeを起動し、リモートコントロールを可能にし、`./test`フォルダ内のHTMLファイルに関連付けられたテストを実行します。これには、ライブラリの未圧縮バージョンと圧縮バージョンの両方に対するユニットテストと、すべての参照例のテストが含まれます。


```
mochaTest
```
`mochaChrome`とは異なり、このステップはnode.js上で実行され、Chromeでは実行されません。そして、ライブラリのごく一部の機能のみをテストします。p5.jsのほとんどの機能はブラウザ環境を必要とするため、新しいテストが実際にブラウザ環境を必要としない場合にのみ、このテストコレクションを拡張すべきです。


```
nyc:report
```
最後に、すべてのビルドとテストが完了した後、このステップでは`mochaChrome`がライブラリの完全バージョンに対して行ったテストカバレッジレポートを収集し、テストカバレッジデータをコンソールに出力します。p5.jsのテストカバレッジは、主に監視といくつかの追加データポイントを提供するために使用されます。私たちの目標は、100%のテストカバレッジを達成することではありません。

これで、Gruntfile.jsの設定でのデフォルトタスクについての説明をカバーしました！


## 雑務タスク
必要に応じて、`npx grunt [step]`を使用して、すべてのステップ、サブステップ、サブサブステップを直接実行することができますが、特定のステップがこの連鎖の以前のステップに依存している場合、操作してもあまり意味がない場合があります。また、上記で触れられていないが、特定の状況で役立つ可能性のあるタスクもいくつかあります。


```
grunt yui:dev
```
このタスクは、上述の文書とライブラリのビルドを実行し、その後、Webサーバーを起動して、[http://localhost:9001/docs/reference/](http://localhost:9001/docs/reference/)の参照ページの機能に似たバージョンを提供します。その後、ソースコードの変更を監視し、文書とライブラリを再構築します。

インラインドキュメントで作業している場合、これは便利です。なぜなら、ビルドされたファイルをp5.jsリポジトリからローカルのp5.js-websiteリポジトリに移動してサイトを再構築する必要がなく、ブラウザで変更をプレビューできるからです。この方法で、変更がサイト上で正しく表示される可能性が高くなります。ただし、この使用はインラインドキュメントの変更に限られ、参照ページ自体の変更（スタイルやレイアウトを含む）はウェブサイトリポジトリで行い、テストする必要があります。


```
grunt watch
grunt watch:main
grunt watch:quick
```
watchタスクは、一連のファイルの変更を監視し、変更されたファイルに基づいて関連タスクを実行して、参照文書やライブラリを構築します。これらのタスクの機能は同じで、唯一の違いはスコープです。

`watch`タスクは、ソースコードの変更が検出された場合、すべてのビルドとテストを実行します。これは、ソースコードで完全なデフォルトタスクを実行するのと同様です。

`watch:main`タスクは、ソースコードの変更が検出された場合、ライブラリのビルドとテストを実行しますが、参照文書は再構築しません。

`watch:quick`タスクは、ソースコードの変更が検出された場合、ライブラリのビルドのみを実行します。

作業内容に応じて、最も簡略化されたwatchタスクを選択することで、手動で再ビルドする時間を節約できます。

---

# リリースプロセス
[release_process.md](./release_process.md)を参照してください。

---

# ヒントとテクニック
時には、レビューする問題やPRの数が圧倒的になることがあります。私たちはプロセスを簡素化するために努力していますが、問題やPRをレビューするのに役立ついくつかのヒントとテクニックを利用することができます。

## 返信テンプレート
GitHubの[Saved Replies](https://docs.github.com/en/get-started/writing-on-github/working-with-saved-replies/about-saved-replies)機能を使用することができます。これは、問題やPRに返信する際に便利な機能で、作業フローで説明されているいくつかのステップ（問題をフォーラムにリダイレクトする、修正のために問題を受け入れるなど）に同じ、または非常に似た返信を使用する必要がある場合、Saved Repliesを使用すると効率が向上します。

以下は、p5.jsのメンテナーが使用しているいくつかのSaved Repliesです。これらを使用することも、自分自身のSaved Repliesを作成することもできます！

#### 閉じる：再現不可
> この問題を再現することができませんでしたが、問題のコード例を提供できる場合は、いつでも再開してください。ありがとうございます！

#### 閉じる：コードスニペットが必要
> 組織の目的のために、この問題を閉じます。問題を示すコードスニペットを提供できる場合は、再開してください。ありがとうございます！

#### 閉じる：フォーラムを使用してください！
> ここでのGitHubの問題は、p5.jsライブラリ自体のバグや問題を報告するのに適しています。自分のコードの作成、テスト、チュートリアルのフォローに関する質問がある場合は、[フォーラム](https://discourse.processing.org/)で投稿してください。ありがとうございます！

#### 閉じる：GSOC
> ありがとうございます！GSOC提案について話し合う最適な場所は、私たちの[フォーラム](https://discourse.processing.org/c/summer-of-code)です。

#### 閉じる：アクセス権
> この問題を一時的に閉じます。なぜなら、[アクセス権を広げる](https://github.com/processing/p5.js/blob/main/contributor_docs/access.md)に関するより詳細な説明が見られなかったからです。問題リクエストにアクセス権に関するより詳細な説明を追加できる場合は、いつでも再開してください。

> この問題を一時的に閉じます。なぜなら、[アクセス権を広げる](https://github.com/processing/p5.js/blob/main/contributor_docs/access.md)に関するより詳細な説明が見られなかったからです。機能リクエストにアクセス権に関するより詳細な説明を追加できる場合は、いつでも再開してください。ありがとうございます！

#### 閉じる：プラグイン
> この機能はp5.js APIの範囲を超えていると思われます（私たちはできるだけシンプルに保つようにしていますが）、しかし、これは良いプラグインライブラリの出発点になる可能性があります。プラグインを作成する方法については、こちらのドキュメントをご覧ください：https://github.com/processing/p5.js/blob/main/contributor_docs/creating_libraries.md

#### PRを閉じる：問題を先に提出してください
> ありがとうございます。リマインダーとして、プルリクエストを開く前に問題を開き、プルリクエストに問題タグを使用する必要があります。これは、開発を追跡し、議論を明確に保つために必要です。ありがとうございます！

#### 問題修正の承認
修正を進めることができます。ありがとうございます。

#### PRをマージ
良さそうです。ありがとうございます！

## GitHub CLI
複雑なPRのレビューを行う際に、複雑なgitコマンドを使用してPRのコードを取得し、ローカルでテストを行うことは困難になる可能性があります。幸いなことに、[GitHub CLI](https://cli.github.com/) ツールは、このプロセスやその他の操作を大幅に簡素化するのに大いに役立ちます。

CLIをインストールしてログインした後、`gh pr checkout [pull_request_id]` コマンドを実行するだけで、PRをローカルでレビューできます。このコマンドは、リモートフォークを自動的に取得し、ブランチを作成してそのブランチに切り替えます。メインブランチに戻るには、ブランチを切り替えるように `git checkout main` を実行するだけです。CLIから直接PRにコメントを残すこともできますので、ウェブページを訪れる必要はありません！

GitHub CLIは、他にも多くのコマンドを提供しており、それらが役立つことがあるでしょう。とにかく、これは素晴らしいツールです。

## 通知の管理
リポジトリの「Issues」や「Pull Requests」タブを手動で監視して、新しい問題やPRをチェックする必要はもうありません。リポジトリページの上部にあるリポジトリ名の反対側にある目のアイコンの「Watch」ボタンをクリックして、そのリポジトリを「Watch」することができます。リポジトリを「Watch」すると、新しい問題、新しいpull requests、あなたのユーザ名の言及、およびリポジトリで購読したその他の活動が、[通知ページ](https://github.com/notifications)に通知として送られます。これらは、電子メールの受信トレイを処理するように、既読にするか無視することができます。

場合によっては、フォローしているリポジトリの活動に関連する電子メールをGitHubから受け取ることがありますが、[通知設定ページ](https://github.com/settings/notifications)でカスタマイズ設定を行うことができます、完全に購読解除を含みます。

これらの通知をあなたの作業スタイルに合わせて設定することで、関連する問題/PRを手動で検索する必要がなくなり、終わりのないGitHubの通知に圧倒されることを避けることができます。ここではバランスが重要です。初期の提案として、リポジトリの「Issues」と「Pull Requests」をフォローし、「参加、言及、カスタム」時にのみ電子メール通知を受け取る設定をお勧めします。

